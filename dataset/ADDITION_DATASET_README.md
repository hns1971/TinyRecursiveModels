# 加法数据集生成说明

## 概述

这个脚本用于生成任意数加法的训练数据集，使用4行n列的网格格式：
- **第1行**：第一个加数
- **第2行**：第二个加数  
- **第3行**：进位数（逐步填充）
- **第4行**：结果（逐步填充）

数据集保留了所有中间步骤，从个位开始逐步计算到最高位。

## 使用方法

### 基本用法

```bash
cd /root/hns/TinyRecursiveModels
python -m dataset.build_addition_dataset
```

### 自定义参数

```bash
python -m dataset.build_addition_dataset \
  --output-dir data/addition \
  --train-size 10000 \
  --test-size 1000 \
  --min-digits 2 \
  --max-digits 10 \
  --num-aug 1
```

### 参数说明

- `--output-dir`: 输出目录（默认：`data/addition`）
- `--train-size`: 训练集puzzle数量（默认：10000）
- `--test-size`: 测试集puzzle数量（默认：1000）
- `--min-digits`: 最小数字位数（默认：2）
- `--max-digits`: 最大数字位数（默认：10）
- `--num-aug`: 数据增强倍数（交换两个加数的顺序，默认：1，即每个puzzle生成2个样本）

## 数据格式

### 网格布局

每个样本是一个4行×(max_len+1)列的网格：

```
示例：123 + 456 = 579

完整轨迹：s₀（初始状态）, s₁, s₂, s₃（最终状态）

s₀（初始状态）：
[0 1 2 3]  <- 第一个加数（右对齐）
[0 4 5 6]  <- 第二个加数（右对齐）
[0 0 0 0]  <- 进位数（空白）
[0 0 0 0]  <- 结果（空白）

s₁（第1步后）：
[0 1 2 3]
[0 4 5 6]
[0 0 0 0]  <- 个位的进位输入（0）
[0 0 0 9]  <- 个位的结果（9）

s₂（第2步后）：
[0 1 2 3]
[0 4 5 6]
[0 0 0 1]  <- 十位的进位输入（1）
[0 0 7 9]  <- 十位和个位的结果（79）

s₃（第3步后，最终状态）：
[0 1 2 3]
[0 4 5 6]
[0 0 1 1]  <- 百位的进位输入（1）
[0 5 7 9]  <- 最终结果（579）

训练样本对（新格式）：
- 每道题目生成一条数据：input=s₀, label=[s₁, s₂, s₃, ...]
  - 输入：初始状态 s₀（4行×max_len列的网格）
  - 标签：所有中间步骤的序列拼接（s₁, s₂, s₃, ... 按顺序拼接成一个长序列）

这样每道题目的完整推理过程都在一条数据中，模型可以学习从初始状态到最终状态的完整轨迹。
```

### 数据文件结构

生成的数据集目录结构：

```
data/addition/
├── train/
│   ├── all__inputs.npy      # 输入网格（展平）
│   ├── all__labels.npy       # 标签网格（每一步的状态）
│   ├── all__puzzle_identifiers.npy
│   ├── all__puzzle_indices.npy
│   ├── all__group_indices.npy
│   └── dataset.json          # 元数据
├── test/
│   └── ... (同上)
└── identifiers.json
```

### 数据特点

1. **完整轨迹学习**：每道题目生成一条数据，包含完整的推理过程
   - 输入：初始状态 s₀（4行×max_len列的网格）
   - 标签：所有中间步骤的序列拼接 [s₁, s₂, s₃, ...]
   - 这样模型可以学习从初始状态到最终状态的完整推理轨迹
2. **保留中间步骤**：所有中间步骤都包含在标签中，模型可以学习完整的计算过程
3. **逐步推理**：从个位开始，逐步计算到最高位
4. **进位处理**：正确处理进位，包括最高位的进位
5. **数据增强**：通过交换两个加数的顺序增加数据多样性

## 测试

运行测试脚本验证逻辑：

```bash
python dataset/test_addition_standalone.py
```

## 注意事项

1. 网格宽度是 `max_len + 1`，为结果可能多一位预留空间
2. 数字是右对齐的，个位在网格的最右边
3. 每个puzzle的所有步骤组成一个group，用于训练时的批处理

